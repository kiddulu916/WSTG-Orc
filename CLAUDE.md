# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

WSTG-Orc is a Web Application Security Testing Orchestration Framework aligned with OWASP WSTG (Web Security Testing Guide). It orchestrates modular security testing phases from a black-box/bug bounty perspective with strict data chaining between modules, state persistence, and structured evidence collection.

## Tech Stack

- **Language:** Python 3.11+
- **Dependencies:** PyYAML (>=6.0), requests (>=2.31), aiohttp (>=3.9)
- **Testing:** pytest with unittest.mock
- **Optional external tools:** nmap, subfinder, amass, gau, httpx, gobuster, whatweb, sqlmap, commix, kiterunner (graceful degradation if unavailable)

## Common Commands

```bash
pip install -r requirements.txt          # Install dependencies
python main.py --new                     # Interactive scope builder + run
python main.py -c config.yaml -s state.json -e evidence  # Resume from existing state
python main.py -v                        # Verbose logging (DEBUG level)
pytest tests/                            # Run all tests
pytest tests/test_state_manager.py       # Run a single test file
pytest tests/ -v                         # Verbose test output
```

## Architecture

**Entry point:** `main.py` (root directory) creates an `Orchestrator` which wires up all dependencies and registers modules.

**Module system:** All testing modules inherit from `BaseModule` (`wstg_orchestrator/modules/base_module.py`) and implement an async `execute()` method. Six dependencies are injected via constructor: StateManager, ConfigLoader, ScopeChecker, RateLimiter, EvidenceLogger, CallbackServer.

**Execution order** (defined in `main.py::EXECUTION_ORDER` and `PARALLEL_GROUPS`):
1. Reconnaissance
2. Fingerprinting + Configuration Testing (parallel)
3. Auth Testing
4. Authorization + Session Testing (parallel)
5. Input Validation
6. Business Logic
7. API Testing
8. Report Generation

**Data flow between phases:** Modules write discoveries to `StateManager` using `enrich(key, values)` â€” e.g., recon populates `discovered_subdomains` and `live_hosts`, which fingerprinting reads. State keys like `endpoints`, `parameters`, `auth_endpoints`, `api_endpoints`, `potential_idor_candidates`, `inferred_cves` chain data forward through subsequent phases.

**Key patterns:**
- **Scope enforcement:** Every HTTP request is validated via `ScopeChecker.is_in_scope()`. Out-of-scope targets raise `OutOfScopeError`.
- **State persistence:** `StateManager` uses thread-safe atomic writes with `threading.Lock`. Subcategory-level tracking (`mark_subcategory_complete`) enables granular resume within a phase.
- **Rate limiting:** Adaptive backoff on 429/WAF blocks (halve RPS), gradual recovery (RPS * 1.1 up to max).
- **Tool degradation:** External tools are optional. Modules fall back to Python-native alternatives when tools are missing (checked via `CommandRunner.is_tool_available()`).
- **Evidence logging:** Timestamped files organized by phase into subdirectories (tool_output, raw_requests, raw_responses, parsed, evidence, potential_exploits, confirmed_exploits, screenshots).

## Coding Conventions

- Modules use async/await for intra-module concurrency and threads for inter-module parallelism.
- `CommandResult` dataclass captures: returncode, stdout, stderr, tool_missing, timed_out.
- `HttpResponse` dataclass captures full request/response with timing info.
- Tests use pytest fixtures for temp directories and config files, `unittest.mock` / `AsyncMock` for isolation.
- Config is read from a single `config.yaml` (generated by `ScopeBuilder`). State persists to `state.json`.
